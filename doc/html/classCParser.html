<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SnuPL Compiler: CParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SnuPL Compiler
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classCParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SnuPL/0 parser.  
 <a href="classCParser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parser_8h_source.html">parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ce2c31c3fab59fca2137e6547ca79f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a1ce2c31c3fab59fca2137e6547ca79f9">CParser</a> (<a class="el" href="classCScanner.html">CScanner</a> *scanner)</td></tr>
<tr class="memdesc:a1ce2c31c3fab59fca2137e6547ca79f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#a1ce2c31c3fab59fca2137e6547ca79f9">More...</a><br/></td></tr>
<tr class="separator:a1ce2c31c3fab59fca2137e6547ca79f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9607221a9578b20be8e4ac41640ac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstNode.html">CAstNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a5d9607221a9578b20be8e4ac41640ac8">Parse</a> (void)</td></tr>
<tr class="memdesc:a5d9607221a9578b20be8e4ac41640ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a module  <a href="#a5d9607221a9578b20be8e4ac41640ac8">More...</a><br/></td></tr>
<tr class="separator:a5d9607221a9578b20be8e4ac41640ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8d3b3514bb26761dd840a43899a60c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a8d3b3514bb26761dd840a43899a60c98">SetError</a> (<a class="el" href="classCToken.html">CToken</a> t, const string message)</td></tr>
<tr class="memdesc:a8d3b3514bb26761dd840a43899a60c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the token causing a parse error along with a message  <a href="#a8d3b3514bb26761dd840a43899a60c98">More...</a><br/></td></tr>
<tr class="separator:a8d3b3514bb26761dd840a43899a60c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036593159f9387e1f9604e2790a8d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#af036593159f9387e1f9604e2790a8d86">Consume</a> (<a class="el" href="scanner_8h.html#a9093554967c90043b2a4a74c028f3f08">EToken</a> <a class="el" href="classCParser.html#a5892cb57efc78876ebbabb1a1f87d2ac">type</a>, <a class="el" href="classCToken.html">CToken</a> *token=NULL)</td></tr>
<tr class="memdesc:af036593159f9387e1f9604e2790a8d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">consume a token given type and optionally store the token  <a href="#af036593159f9387e1f9604e2790a8d86">More...</a><br/></td></tr>
<tr class="separator:af036593159f9387e1f9604e2790a8d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fb208a17e733f5ce3ca866bce7387f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a79fb208a17e733f5ce3ca866bce7387f">InitSymbolTable</a> (<a class="el" href="classCSymtab.html">CSymtab</a> *s)</td></tr>
<tr class="memdesc:a79fb208a17e733f5ce3ca866bce7387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize symbol table <em>s</em> with predefined procedures and global variables  <a href="#a79fb208a17e733f5ce3ca866bce7387f">More...</a><br/></td></tr>
<tr class="separator:a79fb208a17e733f5ce3ca866bce7387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">methods for recursive-descent parsing</div></td></tr>
<tr class="memitem:a608abf6627862b02dff4e2146416d81e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstModule.html">CAstModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a608abf6627862b02dff4e2146416d81e">module</a> (void)</td></tr>
<tr class="memdesc:a608abf6627862b02dff4e2146416d81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scope for module. Takes no parameter.  <a href="#a608abf6627862b02dff4e2146416d81e">More...</a><br/></td></tr>
<tr class="separator:a608abf6627862b02dff4e2146416d81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b3a1e6c92caee041d937a5c98b492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatement.html">CAstStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#ab80b3a1e6c92caee041d937a5c98b492">statSequence</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:ab80b3a1e6c92caee041d937a5c98b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for sequence of statements.  <a href="#ab80b3a1e6c92caee041d937a5c98b492">More...</a><br/></td></tr>
<tr class="separator:ab80b3a1e6c92caee041d937a5c98b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b8e7d702308e517cfb0547a27d9dce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatIf.html">CAstStatIf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a11b8e7d702308e517cfb0547a27d9dce">ifStatement</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:a11b8e7d702308e517cfb0547a27d9dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for if statement.  <a href="#a11b8e7d702308e517cfb0547a27d9dce">More...</a><br/></td></tr>
<tr class="separator:a11b8e7d702308e517cfb0547a27d9dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8007208e69c368e50bf08a5b9c0bf847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatWhile.html">CAstStatWhile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a8007208e69c368e50bf08a5b9c0bf847">whileStatement</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:a8007208e69c368e50bf08a5b9c0bf847"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for while statement.  <a href="#a8007208e69c368e50bf08a5b9c0bf847">More...</a><br/></td></tr>
<tr class="separator:a8007208e69c368e50bf08a5b9c0bf847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2e25ae8f0739f2c2c736a4d866914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatReturn.html">CAstStatReturn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a42d2e25ae8f0739f2c2c736a4d866914">returnStatement</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:a42d2e25ae8f0739f2c2c736a4d866914"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for return statement.  <a href="#a42d2e25ae8f0739f2c2c736a4d866914">More...</a><br/></td></tr>
<tr class="separator:a42d2e25ae8f0739f2c2c736a4d866914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb25a8f4c093c2afa9b1fd582558b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatAssign.html">CAstStatAssign</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#acbb25a8f4c093c2afa9b1fd582558b25">assignment</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s, <a class="el" href="classCToken.html">CToken</a> *commonFirst)</td></tr>
<tr class="memdesc:acbb25a8f4c093c2afa9b1fd582558b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for assignment statement.  <a href="#acbb25a8f4c093c2afa9b1fd582558b25">More...</a><br/></td></tr>
<tr class="separator:acbb25a8f4c093c2afa9b1fd582558b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403701cd62ce8b14fd240457999612af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstStatCall.html">CAstStatCall</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a403701cd62ce8b14fd240457999612af">subroutineCall</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s, <a class="el" href="classCToken.html">CToken</a> *prevToken, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm)</td></tr>
<tr class="memdesc:a403701cd62ce8b14fd240457999612af"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for subroutine call.  <a href="#a403701cd62ce8b14fd240457999612af">More...</a><br/></td></tr>
<tr class="separator:a403701cd62ce8b14fd240457999612af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7852ab9a6c8bb432f771a578e26d36f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstExpression.html">CAstExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#ab7852ab9a6c8bb432f771a578e26d36f">expression</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:ab7852ab9a6c8bb432f771a578e26d36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for expression.  <a href="#ab7852ab9a6c8bb432f771a578e26d36f">More...</a><br/></td></tr>
<tr class="separator:ab7852ab9a6c8bb432f771a578e26d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96bce53cd6e0a0093d6ceed571e6d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstExpression.html">CAstExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#af96bce53cd6e0a0093d6ceed571e6d72">simpleexpr</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:af96bce53cd6e0a0093d6ceed571e6d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for simple expression.  <a href="#af96bce53cd6e0a0093d6ceed571e6d72">More...</a><br/></td></tr>
<tr class="separator:af96bce53cd6e0a0093d6ceed571e6d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91bb89e981a45a0d9332ed0c1ce9537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstExpression.html">CAstExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#ad91bb89e981a45a0d9332ed0c1ce9537">term</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:ad91bb89e981a45a0d9332ed0c1ce9537"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for term.  <a href="#ad91bb89e981a45a0d9332ed0c1ce9537">More...</a><br/></td></tr>
<tr class="separator:ad91bb89e981a45a0d9332ed0c1ce9537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb9499395df05708e93ac0e5c553411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstExpression.html">CAstExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a3fb9499395df05708e93ac0e5c553411">factor</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s)</td></tr>
<tr class="memdesc:a3fb9499395df05708e93ac0e5c553411"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for this factor.  <a href="#a3fb9499395df05708e93ac0e5c553411">More...</a><br/></td></tr>
<tr class="separator:a3fb9499395df05708e93ac0e5c553411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ea1e5f554acf67db9a07e9eff1f6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstConstant.html">CAstConstant</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a77ea1e5f554acf67db9a07e9eff1f6fd">number</a> (void)</td></tr>
<tr class="separator:a77ea1e5f554acf67db9a07e9eff1f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5892cb57efc78876ebbabb1a1f87d2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a5892cb57efc78876ebbabb1a1f87d2ac">type</a> (<a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, bool _isParam)</td></tr>
<tr class="memdesc:a5892cb57efc78876ebbabb1a1f87d2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting type of variable, parameter or function.  <a href="#a5892cb57efc78876ebbabb1a1f87d2ac">More...</a><br/></td></tr>
<tr class="separator:a5892cb57efc78876ebbabb1a1f87d2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa151095c29b50a41877e16b88ee73bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#aa151095c29b50a41877e16b88ee73bb0">GetVariables</a> (<a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, vector&lt; <a class="el" href="classCToken.html">CToken</a> * &gt; *varVec)</td></tr>
<tr class="memdesc:aa151095c29b50a41877e16b88ee73bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one type of variables for procedure/function or global module and store them to vector.  <a href="#aa151095c29b50a41877e16b88ee73bb0">More...</a><br/></td></tr>
<tr class="separator:aa151095c29b50a41877e16b88ee73bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450b633391f1133e2f6f273a73beda15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a450b633391f1133e2f6f273a73beda15">GetOneTypeParams</a> (<a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; *paramVec, vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *originVec, int idx)</td></tr>
<tr class="memdesc:a450b633391f1133e2f6f273a73beda15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one type of parameters for procedure/function.  <a href="#a450b633391f1133e2f6f273a73beda15">More...</a><br/></td></tr>
<tr class="separator:a450b633391f1133e2f6f273a73beda15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ce2e9d1613583a698d190a57a10247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a27ce2e9d1613583a698d190a57a10247">GetParams</a> (<a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *paramVec1, int lastIdx)</td></tr>
<tr class="memdesc:a27ce2e9d1613583a698d190a57a10247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets parameters for procedure/function.  <a href="#a27ce2e9d1613583a698d190a57a10247">More...</a><br/></td></tr>
<tr class="separator:a27ce2e9d1613583a698d190a57a10247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365792f62ff3fc86556b7be7b4459025"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a365792f62ff3fc86556b7be7b4459025">GenerateArrayType</a> (<a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, <a class="el" href="classCType.html">CType</a> *_baseType, bool _isParam)</td></tr>
<tr class="memdesc:a365792f62ff3fc86556b7be7b4459025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Array type for given base type. May use recursive call to this function for getting multiple dimension array.  <a href="#a365792f62ff3fc86556b7be7b4459025">More...</a><br/></td></tr>
<tr class="separator:a365792f62ff3fc86556b7be7b4459025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efca0ae8ffe0a78cea3ca6908e4779d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCType.html">CType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a1efca0ae8ffe0a78cea3ca6908e4779d">GeneratePointerType</a> (<a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, <a class="el" href="classCType.html">CType</a> *_baseType)</td></tr>
<tr class="separator:a1efca0ae8ffe0a78cea3ca6908e4779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c0eb96d443f7155ac1f2270af4e712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a51c0eb96d443f7155ac1f2270af4e712">AddArguments</a> (<a class="el" href="classCAstScope.html">CAstScope</a> *s, <a class="el" href="classCScanner.html">CScanner</a> *<a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a>, <a class="el" href="classCTypeManager.html">CTypeManager</a> *_tm, <a class="el" href="classCAstFunctionCall.html">CAstFunctionCall</a> *_fc, int nParams)</td></tr>
<tr class="memdesc:a51c0eb96d443f7155ac1f2270af4e712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add argument to given function call.  <a href="#a51c0eb96d443f7155ac1f2270af4e712">More...</a><br/></td></tr>
<tr class="separator:a51c0eb96d443f7155ac1f2270af4e712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7416b72e9279db1d3b569465cdb22d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a7416b72e9279db1d3b569465cdb22d6e">CheckParamDups</a> (vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *paramVec, const string elemToFind)</td></tr>
<tr class="memdesc:a7416b72e9279db1d3b569465cdb22d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check parameter duplication for given name string.  <a href="#a7416b72e9279db1d3b569465cdb22d6e">More...</a><br/></td></tr>
<tr class="separator:a7416b72e9279db1d3b569465cdb22d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b84611747b3856d2d59ba94073dfb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstExpression.html">CAstExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#af8b84611747b3856d2d59ba94073dfb6">getBinaryLHS</a> (<a class="el" href="classCAstBinaryOp.html">CAstBinaryOp</a> *_lhs, bool _isNeg, bool _isPos)</td></tr>
<tr class="memdesc:af8b84611747b3856d2d59ba94073dfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expression with negative or positive operator applied.  <a href="#af8b84611747b3856d2d59ba94073dfb6">More...</a><br/></td></tr>
<tr class="separator:af8b84611747b3856d2d59ba94073dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebde2ae35f257dee85d80a3735263c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a7ebde2ae35f257dee85d80a3735263c2">isLeftmostConstant</a> (<a class="el" href="classCAstBinaryOp.html">CAstBinaryOp</a> *_lhs)</td></tr>
<tr class="memdesc:a7ebde2ae35f257dee85d80a3735263c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if leftmost operand of given binary operator is constant or not.  <a href="#a7ebde2ae35f257dee85d80a3735263c2">More...</a><br/></td></tr>
<tr class="separator:a7ebde2ae35f257dee85d80a3735263c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a90bb0e8599f6a4513e9c31d34384c7bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a90bb0e8599f6a4513e9c31d34384c7bd">_scanner</a></td></tr>
<tr class="memdesc:a90bb0e8599f6a4513e9c31d34384c7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCScanner.html" title="scanner ">CScanner</a> instance.  <a href="#a90bb0e8599f6a4513e9c31d34384c7bd">More...</a><br/></td></tr>
<tr class="separator:a90bb0e8599f6a4513e9c31d34384c7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad789efb0f1d2e569a50e7fef3e7154e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCAstModule.html">CAstModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#ad789efb0f1d2e569a50e7fef3e7154e1">_module</a></td></tr>
<tr class="memdesc:ad789efb0f1d2e569a50e7fef3e7154e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">root node of the program  <a href="#ad789efb0f1d2e569a50e7fef3e7154e1">More...</a><br/></td></tr>
<tr class="separator:ad789efb0f1d2e569a50e7fef3e7154e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838118a06262ccff4bc2f7b57ebb9e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCToken.html">CToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a838118a06262ccff4bc2f7b57ebb9e88">_token</a></td></tr>
<tr class="memdesc:a838118a06262ccff4bc2f7b57ebb9e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">current token  <a href="#a838118a06262ccff4bc2f7b57ebb9e88">More...</a><br/></td></tr>
<tr class="separator:a838118a06262ccff4bc2f7b57ebb9e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
error handling</h2></td></tr>
<tr class="memitem:adb078130bea94f1bfad73764aae1afa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCToken.html">CToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#adb078130bea94f1bfad73764aae1afa1">_error_token</a></td></tr>
<tr class="memdesc:adb078130bea94f1bfad73764aae1afa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">error token  <a href="#adb078130bea94f1bfad73764aae1afa1">More...</a><br/></td></tr>
<tr class="separator:adb078130bea94f1bfad73764aae1afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8fbbaa9134bec8b792d538f62d348"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a8bb8fbbaa9134bec8b792d538f62d348">_message</a></td></tr>
<tr class="memdesc:a8bb8fbbaa9134bec8b792d538f62d348"><td class="mdescLeft">&#160;</td><td class="mdescRight">error message  <a href="#a8bb8fbbaa9134bec8b792d538f62d348">More...</a><br/></td></tr>
<tr class="separator:a8bb8fbbaa9134bec8b792d538f62d348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bffc39f5af45a8819bb35af72f7f9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a14bffc39f5af45a8819bb35af72f7f9c">_abort</a></td></tr>
<tr class="memdesc:a14bffc39f5af45a8819bb35af72f7f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">error flag  <a href="#a14bffc39f5af45a8819bb35af72f7f9c">More...</a><br/></td></tr>
<tr class="separator:a14bffc39f5af45a8819bb35af72f7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d97ee936fd96af9b1db0a08d80cfdfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a4d97ee936fd96af9b1db0a08d80cfdfe">HasError</a> (void) const </td></tr>
<tr class="memdesc:a4d97ee936fd96af9b1db0a08d80cfdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether there was an error while parsing the source  <a href="#a4d97ee936fd96af9b1db0a08d80cfdfe">More...</a><br/></td></tr>
<tr class="separator:a4d97ee936fd96af9b1db0a08d80cfdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adbe55b1ead5a60695f803e49a858b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCToken.html">CToken</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#af6adbe55b1ead5a60695f803e49a858b">GetErrorToken</a> (void) const </td></tr>
<tr class="memdesc:af6adbe55b1ead5a60695f803e49a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the token that caused the error  <a href="#af6adbe55b1ead5a60695f803e49a858b">More...</a><br/></td></tr>
<tr class="separator:af6adbe55b1ead5a60695f803e49a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6b3e3141aa9cad9fd0945dbd545045"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCParser.html#a6b6b3e3141aa9cad9fd0945dbd545045">GetErrorMessage</a> (void) const </td></tr>
<tr class="memdesc:a6b6b3e3141aa9cad9fd0945dbd545045"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a human-readable error message  <a href="#a6b6b3e3141aa9cad9fd0945dbd545045">More...</a><br/></td></tr>
<tr class="separator:a6b6b3e3141aa9cad9fd0945dbd545045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SnuPL/0 parser. </p>
<dl class="section author"><dt>Author</dt><dd>Bernhard Egger <a href="#" onclick="location.href='mai'+'lto:'+'ber'+'nh'+'ard'+'@c'+'sap'+'.s'+'nu.'+'ac'+'.kr'; return false;">bernh<span style="display: none;">.nosp@m.</span>ard@<span style="display: none;">.nosp@m.</span>csap.<span style="display: none;">.nosp@m.</span>snu.<span style="display: none;">.nosp@m.</span>ac.kr</a> </dd></dl>
<h1><a class="anchor" id="changelog"></a>
Change Log</h1>
<p>2012/09/14 Bernhard Egger created 2013/03/07 Bernhard Egger adapted to SnuPL/0 2016/03/09 Bernhard Egger adapted to SnuPL/1 2016/04/08 Bernhard Egger assignment 2: parser for SnuPL/-1</p>
<h1><a class="anchor" id="license_section"></a>
License</h1>
<p>Copyright (c) 2012-2016, Bernhard Egger All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modifi- cation, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSE- QUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. parser</p>
<p>parses a module </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00049">49</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ce2c31c3fab59fca2137e6547ca79f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CParser::CParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>scanner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scanner</td><td><a class="el" href="classCScanner.html" title="scanner ">CScanner</a> from which the input stream is read </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00197">197</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a51c0eb96d443f7155ac1f2270af4e712"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::AddArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCAstFunctionCall.html">CAstFunctionCall</a> *&#160;</td>
          <td class="paramname"><em>_fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add argument to given function call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for function call to add parameter. </td></tr>
    <tr><td class="paramname">_scanner</td><td>Scanner. </td></tr>
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
    <tr><td class="paramname">_fc</td><td>Function call to add arguments. </td></tr>
    <tr><td class="paramname">nParams</td><td>Number of parameters that this function call needs. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00956">956</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbb25a8f4c093c2afa9b1fd582558b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatAssign.html">CAstStatAssign</a> * CParser::assignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCToken.html">CToken</a> *&#160;</td>
          <td class="paramname"><em>commonFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for assignment statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this assignment statement. </td></tr>
    <tr><td class="paramname">commonFirst</td><td>First token for LHS of this assignment. Used to find appropriate symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatAssign*</td><td>Processed assignment statement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01090">1090</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7416b72e9279db1d3b569465cdb22d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::CheckParamDups </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>elemToFind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check parameter duplication for given name string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramVec</td><td>Parameter vector that contains parameters read. </td></tr>
    <tr><td class="paramname">elemToFind</td><td>Name of element to check for duplication.  true when there is duplication.  false when there is no duplication. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00596">596</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af036593159f9387e1f9604e2790a8d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::Consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="scanner_8h.html#a9093554967c90043b2a4a74c028f3f08">EToken</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCToken.html">CToken</a> *&#160;</td>
          <td class="paramname"><em>token</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>consume a token given type and optionally store the token </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>expected token type </td></tr>
    <tr><td class="paramname">token</td><td>If not null, the consumed token is stored in 'token' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if a token has been consumed </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00244">244</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7852ab9a6c8bb432f771a578e26d36f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstExpression.html">CAstExpression</a> * CParser::expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstExpression*</td><td>Processed expression. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01161">1161</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fb9499395df05708e93ac0e5c553411"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstExpression.html">CAstExpression</a> * CParser::factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for this factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstExpression*</td><td>Processed factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01685">1685</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a365792f62ff3fc86556b7be7b4459025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCType.html">CType</a> * CParser::GenerateArrayType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCType.html">CType</a> *&#160;</td>
          <td class="paramname"><em>_baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_isParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets Array type for given base type. May use recursive call to this function for getting multiple dimension array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_scanner</td><td>Scanner. </td></tr>
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
    <tr><td class="paramname">_baseType</td><td>Base type that this array will contain.  Array type of given base type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00750">750</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1efca0ae8ffe0a78cea3ca6908e4779d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCType.html">CType</a>* CParser::GeneratePointerType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCType.html">CType</a> *&#160;</td>
          <td class="paramname"><em>_baseType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8b84611747b3856d2d59ba94073dfb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstExpression.html">CAstExpression</a> * CParser::getBinaryLHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstBinaryOp.html">CAstBinaryOp</a> *&#160;</td>
          <td class="paramname"><em>_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_isNeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_isPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expression with negative or positive operator applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lhs</td><td>Binary operator expression to apply unary operator. </td></tr>
    <tr><td class="paramname">_isNeg</td><td>Indicates whether unary operator to apply is negative. </td></tr>
    <tr><td class="paramname">_isPos</td><td>Indicates whether unary operator to apply is positive._abort  Expression with unary operator applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01236">1236</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b6b3e3141aa9cad9fd0945dbd545045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string CParser::GetErrorMessage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a human-readable error message </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">error</td><td>message </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00230">230</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6adbe55b1ead5a60695f803e49a858b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCToken.html">CToken</a> * CParser::GetErrorToken </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the token that caused the error </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="classCToken.html" title="token ">CToken</a></td><td>containing the error token </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00224">224</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a450b633391f1133e2f6f273a73beda15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCType.html">CType</a> * CParser::GetOneTypeParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; *&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *&#160;</td>
          <td class="paramname"><em>originVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets one type of parameters for procedure/function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_scanner</td><td>Scanner </td></tr>
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
    <tr><td class="paramname">paramVec</td><td>parameter vector for one type. </td></tr>
    <tr><td class="paramname">originVec</td><td>Vector for whole parameter, more than one type. Used to check duplication. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of parameter.  Type of read parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00663">663</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27ce2e9d1613583a698d190a57a10247"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCType.html">CType</a> * CParser::GetParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="classCSymParam.html">CSymParam</a> * &gt; &gt; *&#160;</td>
          <td class="paramname"><em>paramVec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets parameters for procedure/function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_scanner</td><td>Scanner. </td></tr>
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
    <tr><td class="paramname">paramVec1</td><td>Vector for containing parameters read, may contain multiple types. </td></tr>
    <tr><td class="paramname">lastIdx</td><td>Indicates how many parameters are read before this function is called.  Type of last read parameter. This is not used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00707">707</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa151095c29b50a41877e16b88ee73bb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCType.html">CType</a> * CParser::GetVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCScanner.html">CScanner</a> *&#160;</td>
          <td class="paramname"><em>_scanner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classCToken.html">CToken</a> * &gt; *&#160;</td>
          <td class="paramname"><em>varVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets one type of variables for procedure/function or global module and store them to vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_scanner</td><td>Scanner </td></tr>
    <tr><td class="paramname">varVec</td><td>Vector for storing tokens.  Returns the type of read variables. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00729">729</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d97ee936fd96af9b1db0a08d80cfdfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::HasError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates whether there was an error while parsing the source </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the parser detected an error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00066">66</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11b8e7d702308e517cfb0547a27d9dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatIf.html">CAstStatIf</a> * CParser::ifStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for if statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this if statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatIf*</td><td>Processed if statement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01016">1016</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79fb208a17e733f5ce3ca866bce7387f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::InitSymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCSymtab.html">CSymtab</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize symbol table <em>s</em> with predefined procedures and global variables </p>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00260">260</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ebde2ae35f257dee85d80a3735263c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::isLeftmostConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstBinaryOp.html">CAstBinaryOp</a> *&#160;</td>
          <td class="paramname"><em>_lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if leftmost operand of given binary operator is constant or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lhs</td><td>Binary operator expression to check.  true when leftmost operand is constant.  false when leftmost operand is not constant. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01216">1216</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a608abf6627862b02dff4e2146416d81e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstModule.html">CAstModule</a> * CParser::module </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scope for module. Takes no parameter. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstModule*</td><td>for module. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00295">295</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77ea1e5f554acf67db9a07e9eff1f6fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstConstant.html">CAstConstant</a>* CParser::number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d9607221a9578b20be8e4ac41640ac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstNode.html">CAstNode</a> * CParser::Parse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parse a module </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="classCAstNode.html" title="AST base node. ">CAstNode</a></td><td>program node </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00203">203</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42d2e25ae8f0739f2c2c736a4d866914"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatReturn.html">CAstStatReturn</a> * CParser::returnStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for return statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this while statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatReturn*</td><td>Processed return statement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01069">1069</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3b3514bb26761dd840a43899a60c98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::SetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCToken.html">CToken</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the token causing a parse error along with a message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>token causing the error </td></tr>
    <tr><td class="paramname">message</td><td>human-readable error message </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00236">236</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af96bce53cd6e0a0093d6ceed571e6d72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstExpression.html">CAstExpression</a> * CParser::simpleexpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for simple expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this simple expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstExpression*</td><td>Processed simple expression. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01341">1341</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab80b3a1e6c92caee041d937a5c98b492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatement.html">CAstStatement</a> * CParser::statSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for sequence of statements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this sequence of statements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatement*</td><td>Processed statements. May be multiple of them. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00850">850</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a403701cd62ce8b14fd240457999612af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatCall.html">CAstStatCall</a> * CParser::subroutineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCToken.html">CToken</a> *&#160;</td>
          <td class="paramname"><em>prevToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for subroutine call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this subroutine call. </td></tr>
    <tr><td class="paramname">prevToken</td><td>Token that will be the name of subroutine(procedure/function). </td></tr>
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatCall*</td><td>Processed statement call. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00935">935</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad91bb89e981a45a0d9332ed0c1ce9537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstExpression.html">CAstExpression</a> * CParser::term </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstExpression*</td><td>Processed term. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01644">1644</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5892cb57efc78876ebbabb1a1f87d2ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCType.html">CType</a> * CParser::type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCTypeManager.html">CTypeManager</a> *&#160;</td>
          <td class="paramname"><em>_tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_isParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for getting type of variable, parameter or function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tm</td><td>Type manager. </td></tr>
    <tr><td class="paramname">_isParam</td><td>Indicator that type is for parameter or not. When _isParam is true and type is array, it will be referenced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CType*</td><td>that this function got. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00779">779</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8007208e69c368e50bf08a5b9c0bf847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstStatWhile.html">CAstStatWhile</a> * CParser::whileStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCAstScope.html">CAstScope</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AST node for while statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scope for this while statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAstStatWhile*</td><td>Processed while statement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l01047">1047</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a14bffc39f5af45a8819bb35af72f7f9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::_abort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>error flag </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00236">236</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb078130bea94f1bfad73764aae1afa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCToken.html">CToken</a> CParser::_error_token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>error token </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00234">234</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb8fbbaa9134bec8b792d538f62d348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string CParser::_message</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>error message </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00235">235</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad789efb0f1d2e569a50e7fef3e7154e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAstModule.html">CAstModule</a>* CParser::_module</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>root node of the program </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00230">230</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90bb0e8599f6a4513e9c31d34384c7bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCScanner.html">CScanner</a>* CParser::_scanner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCScanner.html" title="scanner ">CScanner</a> instance. </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00229">229</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a838118a06262ccff4bc2f7b57ebb9e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCToken.html">CToken</a> CParser::_token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current token </p>

<p>Definition at line <a class="el" href="parser_8h_source.html#l00231">231</a> of file <a class="el" href="parser_8h_source.html">parser.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="parser_8h_source.html">parser.h</a></li>
<li>src/<a class="el" href="parser_8cpp_source.html">parser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 10 2016 22:53:23 for SnuPL Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
